'''
    For a frame F = (X, R), let ♢ R be the unary operation on the powerset P(X)
    defined as follows: for Y ⊆ X, ♢ R (Y) = R^−1 [Y]

    Exercise 2.16. Let (X, R) be a finite frame. For a family V of subsets of X,
    compute the smallest family [V] of subsets of X that contains V and is closed under
    set-theoretic operations and ♢ R .

    
    Set-theoretic operations

    Powerset closed under union, intersection, set difference
    https://proofwiki.org/wiki/Power_Set_is_Closed_under_Intersection
    

'''


"""
    Computes ♢R (Y) = R^−1 [Y]
"""
def diamond_R(Y, R):
    result = set()
    for (x, y) in R:
        if y in Y:
            result.add(x)
    return result


"""
    Returns the closure of V under set-theoretic operations
"""
def closure_under_set_theoretic_operations(V, X):
    closure = set(V)
    
    # Union, intersection, and complement of subsets in closure
    while True:
        new_sets = set(closure)

        for A in closure:
            new_sets.add(X - A)

            for B in closure:
                new_sets.add(A.union(B))
                new_sets.add(A.intersection(B))
            
        
        if new_sets == closure:
            break
        closure = new_sets
        
    return closure

"""
    Computes the smallest family [V] that contains V and 
    is closed under set-theoretic operations and ♢R
    
"""
def compute_closure(V, R, X):
    closure = set(map(frozenset, V))
    X = frozenset(X)
    
    while True:
        new_closure = set(closure)
        
        # Add ♢R (Y) for each Y in closure
        for Y in closure:
            new_closure.add(frozenset(diamond_R(Y, R)))
        
        # Ensure closure under set-theoretic operations
        new_closure = closure_under_set_theoretic_operations(new_closure, X)
        
        if new_closure == closure:
            break
        
        closure = new_closure
    

    return closure #set(map(set, closure))



"""
    Finds the equivalence classes under the equivalence relation ∼V
    
    Two elements a and b are in the same equivalence class if they 
    belong to exactly the same subsets in [V]
"""

def equivalence_relation_V(X, V):
   
    
    equivalence_classes = {}
    unprocessed = set(X)
    i = 0
    while unprocessed:
        eq_class = set()
        a = unprocessed.pop()

        eq_class.add(a)
        for b in X:
            if all((a in v) == (b in v) for v in V):
                eq_class.add(b)
        
        equivalence_classes[f"V{i}"] = (frozenset(eq_class))
        unprocessed -= eq_class
        i += 1
    
    return equivalence_classes




"""
    Computes the induced relation R̃ on the equivalence classes

"""
def induced_relation(classes, R):
    induced_R = set()
    for name_a, class_a in classes.items():
        for name_b, class_b in classes.items():
            if any((a, b) in R for a in class_a for b in class_b):
                induced_R.add((name_a, name_b))
    return induced_R



'''
    The structure A(F) = (P(X), ∪, ∩, −, ∅, X, ♢ R ) is called the modal
    algebra of F . The structure ([V], ∪, ∩, −, ∅, X, ♢ R ) is called the subalgebra of A(F)
    generated by V.
    
    For a frame F = (X, R) and an equivalence ∼, define the frame F/∼ = (X/∼, R̃),
    where [a] R̃[b] iff a ′ Rb ′ for some a ∼ a ′ and b ∼ b ′ .
    For a family V of subsets of X, consider the equivalence ∼ V on X:
    a ∼ b iff ∀V ∈ V (x ∈ V iff y ∈ V ).

    Exercise 2.18. For a family V of subsets of a finite X, compute the frame F/∼ [V] .

'''
def quotient_frame(X, R, V):

    classes = equivalence_relation_V(X, V)
    induced_R = induced_relation(classes, R)
    return classes, induced_R



def printEquivFrame(pts_sets, R):
    
    print("F/∼ [V]: ")
    print("X: ")
    for my_point, my_set in pts_sets.items():
        print(f"\t{my_point} : {set(my_set)}")
   
    print(f"R: {R}\n")


def printClosure(V,R,X, closure_V):
    print(f"X: {X}")
    print(f"R: {R}")
    print(f"V: {V}")
    
    if closure_V is None:
        print("Closure of V is empty")
    else:
        print(f"Length of [V]: {len(closure_V)}")
        
        print("[V] = {")
        for x in closure_V:
              print(f"\t{set(x)}")
        print("}\n")


def main():


    X = {0, 1, 2, 3,4,5}
    R = {(0, 1), (0,2),(1,3),(1,4),(2,4),(2,5)}
    V = [{0,1},{2,4}]
    
    # [V]
    closure_V = compute_closure(V, R, X)
    printClosure(V,R,X, closure_V)
    # F/∼ [V]
    eq_pts_sets, eq_R = quotient_frame(X, R, closure_V)
    printEquivFrame(eq_pts_sets, eq_R)
    

   
   
    X = {0, 1, 2, 3,4,5,6,7,8,9,10,11}
    R = {(0, 1), (1,2),(2,3),(3,4),(4,5),(5,0),(6,7),(7,8),(8,9),(9,10),(10,11),(11,6)}
    V = [{0,6}]
    
    # [V]
    closure_V = compute_closure(V, R, X)
    printClosure(V,R,X, closure_V)
    # F/∼ [V]
    eq_pts_sets, eq_R = quotient_frame(X, R, closure_V)
    printEquivFrame(eq_pts_sets, eq_R)


    X = {0, 1, 2, 3}
    R = {(0, 1), (1, 3), (3, 0)}
    V = [{0,1,2,3}, {1,2,3}]

    # [V]
    closure_V = compute_closure(V, R, X)
    printClosure(V,R,X, closure_V)
    # F/∼ [V]
    eq_pts_sets, eq_R = quotient_frame(X, R, closure_V)
    printEquivFrame(eq_pts_sets, eq_R)

    X = {0, 1, 2, 3, 4, 5}
    R = {(0, 1), (0,2),(1,2),(1,3),(2,3),(2,4),(3,4),(3,0),(4,0),(4,1)}
    V = [{5}]
    
    # [V]
    closure_V = compute_closure(V, R, X)
    printClosure(V,R,X, closure_V)
    # F/∼ [V]
    eq_pts_sets, eq_R = quotient_frame(X, R, closure_V)
    printEquivFrame(eq_pts_sets, eq_R)

if __name__ == "__main__":
    main()